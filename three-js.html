<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>three-js</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
        <script src="js/three.js"></script>
		<script>			

            const fps = 24;
            const msPerFrame = 1000/fps;
            let readyToRender = true;
            let intervalID;
            let mouseX = 0.0;
            let mouseY = 0.0;
            let indX = 0;
            let indY = 0;
            const damping = 0.99;
            const pointerStrength = 0.3;
            const pointerSize = 4;

            let wX = window.innerWidth;
            let wY = window.innerHeight;
            const wP = window.devicePixelRatio;
            let aspect = wX / wY;

            let ySeg = 64;
            let xSeg = Math.floor(ySeg * aspect);
            let yPoi = ySeg + 1;
            let xPoi = xSeg + 1;
            const segments = 64;
            const points = segments+1;
            const prev = new Array(xPoi * yPoi).fill(0);
            const curr = new Array(xPoi * yPoi).fill(0);
            
            //scene & camera
            const scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xc0c0c0 );
            // const camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0.1, 1000);
            const camera = new THREE.PerspectiveCamera(53, wX / wY, 0.5, 1000)
            camera.position.x = 0;
            camera.position.y = 0;
            camera.position.z = 1;
            camera.lookAt(0,0,0);

            //renderer
            const renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( wP );
            renderer.setSize( wX, wY );
            document.body.appendChild( renderer.domElement );

            // light
            const light = new THREE.DirectionalLight(0xffffff);
            light.position.set(10,0,0);
            //scene.add( light );

            // materials
            const refractiveMat = new THREE.MeshPhysicalMaterial({
                side: THREE.DoubleSide,
                transmission: 1.0,
				roughness: 0,
				ior: 1.333,
				thickness: 10,
            });

            const normalMat = new THREE.MeshNormalMaterial({
                side: THREE.DoubleSide
            });

            const vertMat = new THREE.MeshBasicMaterial({
                vertexColors: true,
                side: THREE.BackSide
            });

            // geometry
            const geometry = new THREE.BufferGeometry();

            //attributes
            const indices = [];
            const vertices = [];
            const normals = [];
            const colors = [];

            // generate vertices, normals and color data for a simple grid geometry
            for ( let i = 0; i <= ySeg; i++ ) {

                const y = i / ySeg;    //set y position from 0 - 1

                for ( let j = 0; j <= xSeg; j++ ) {

                    const x = j / xSeg * aspect;    //set x position from 0 - 1

                    vertices.push( x, y, 0 );
                    normals.push( 0, 0, -1 );

                    colors.push( 0,0,1 );
                }
            }

            // generate indices (data for element array buffer)
            for ( let i = 0; i < ySeg; i++ ) {

                for ( let j = 0; j < xSeg; j++ ) {

                    const a = i * ( xSeg + 1 ) + ( j + 1 );
                    const b = i * ( xSeg + 1 ) + j;
                    const c = ( i + 1 ) * ( xSeg + 1 ) + j;
                    const d = ( i + 1 ) * ( xSeg + 1 ) + ( j + 1 );

                    // generate two faces (triangles) per iteration
                    indices.push( a, b, d ); // face one
                    indices.push( b, c, d ); // face two
                }
            }

            geometry.setIndex( indices );            
            const colorsA = new THREE.Float32BufferAttribute(colors,3);
            const positionsA = new THREE.Float32BufferAttribute(vertices,3);
            const normalsA = new THREE.Float32BufferAttribute(normals,3);
            geometry.setAttribute( 'color', colorsA);
            geometry.setAttribute( 'position', positionsA );
            geometry.setAttribute( 'normal', normalsA );

            const mesh = new THREE.Mesh( geometry, refractiveMat );
            mesh.position.x = -0.5 * aspect;
            mesh.position.y = -0.5;
            scene.add( mesh );

            const torusGeometry = new THREE.TorusKnotGeometry(10, 2.3, 300, 24);
            const bgMesh = new THREE.Mesh( torusGeometry, normalMat);
            bgMesh.position.z = -0.5;
            bgMesh.scale.x = 0.02;
            bgMesh.scale.y = 0.02;
            bgMesh.scale.z = 0.02;
			scene.add(bgMesh);

            document.body.addEventListener( 'pointermove', onPointerMove );

            animate(scene, camera);             

            function queueRender() {
                readyToRender = true;
                clearInterval(intervalID);
            }
            intervalID = setInterval(queueRender, msPerFrame);

            function onPointerMove( event ) {

                if ( event.isPrimary === false ) return;

                mouseX = event.clientX;
                mouseY = event.clientY;

                indX = Math.floor((mouseX / wX) * xPoi);
                indY = Math.floor((1 - mouseY / wY) * yPoi);
                
                for (let i = -(pointerSize-1); i < pointerSize; i++) {
                    const xtemp = i + indX;
                    for (let j = -(pointerSize-1); j < pointerSize; j++) {
                        const ytemp = j + indY;
                        if (0 < xtemp && xtemp < xSeg && 0 < ytemp && ytemp < ySeg) {
                            const indtemp = xtemp + (ytemp * xPoi);
                            prev[indtemp] += pointerStrength * (pointerSize - (Math.abs(i) + Math.abs(j))) / pointerSize;
                        }
                    }
                }

                xPos.innerHTML = mouseX;
                yPos.innerHTML = mouseY;
                indXP.innerHTML = indX;
                indYP.innerHTML = indY;
            }

            function buttonfunc() {
                butt.innerHTML = xPoi;
            }

            function rippleAnimate() {
                for (let x = 1; x < xPoi; x++) {
                    for (let y = 1; y < yPoi; y++) {
                        curr[x + (y * xPoi)] = (prev[(x-1) + y * xPoi] + 
                                                  prev[(x+1) + y * xPoi] + 
                                                  prev[x + (y+1) * xPoi] + 
                                                  prev[x + (y-1) * xPoi]) / 2 - curr[x + (y * xPoi)];
                        curr[x + (y * xPoi)] = curr[x + (y * xPoi)] * damping;
                        curr[x + (y * xPoi)] = isNaN(curr[x + (y * xPoi)]) ? 0 : curr[x + (y * xPoi)];
                    }
                }

                for (let i = 0; i < xPoi*yPoi; i++) {
                    normalsA.setY(i,curr[i]);
                    normalsA.setX(i,curr[i]);
                }

                for (let i = 0; i < xPoi*yPoi; i++) {
                    const temp = prev[i];
                    prev[i] = curr[i];
                    curr[i] = temp;
                }

                normalsA.needsUpdate = true;
            }

            //frame update
            function animate() {
                requestAnimationFrame( animate );

				// bgMesh.rotation.x += 0.01;
				// bgMesh.rotation.y += 0.01;
                
                if (readyToRender) {
                    rippleAnimate()
                    renderer.render( scene, camera );
                    readyToRender = false;
                    intervalID = setInterval(queueRender, msPerFrame);
                }                
            }

            function resizedWindow() {
                wX = window.innerWidth;
                wY = window.innerHeight;
                renderer.setSize(wX, wY);
            }
            window.addEventListener('resize', resizedWindow)
            
		</script>
        <div style="display: flex; flex-direction: column; position: fixed; top: 0; color: white;">
            <p id="xPos">xPos</p>
            <p id="yPos">yPos</p>
            <p id="indXP"></p>
            <p id="indYP"></p>
            <p id="extra"></p>
            <button onclick="buttonfunc()" id="butt" style="width: 100px;">hi</button>
        </div>
	</body>
</html>