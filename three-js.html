<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>three-js</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
        <script src="js/three.js"></script>
		<script>			

            const fps = 60;
            const msPerFrame = 1000/fps;
            let readyToRender = true;
            let mouseX = 0.0;
            let mouseY = 0.0;
            let indX = 0;
            let indY = 0;
            const damping = 0.98;
            const pointerStrength = 0.005;
            const pointerSize = 7;
            const segments = 128;
            const points = segments+1;
            let intervalID;

            function queueRender() {
                readyToRender = true;
                clearInterval(intervalID);
            }
            intervalID = setInterval(queueRender, msPerFrame);
            
            //scene & camera
            const scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x808080 );
            //const camera = new THREE.OrthographicCamera(0, 1, 1, 0, 0.1, 2000);
            const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.5, 1000)
            camera.position.x = 0;
            camera.position.y = 0;
            camera.position.z = 2;
            camera.lookAt(0,0,0);

            //renderer
            const renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            // light
            const light = new THREE.AmbientLight(0xffffff);
            light.position.set(0,0,10);
            scene.add( light );

            // materials
            const refractiveMat = new THREE.MeshPhysicalMaterial({
                roughness: 0.2,
                transmission: 1,
                thickness: 9999,
                side: THREE.DoubleSide
            });

            const normalMat = new THREE.MeshNormalMaterial({
                side: THREE.FrontSide
            });

            const vertMat = new THREE.MeshBasicMaterial({
                vertexColors: true,
                side: THREE.BackSide
            });

            // geometry
            const POINTS_COUNT = 121;
            const geometry = new THREE.BufferGeometry();

            //attributes
            const indices = [];
            const vertices = [];
            const normals = [];
            const colors = [];

            // generate vertices, normals and color data for a simple grid geometry
            for ( let i = 0; i <= segments; i++ ) {

                const y = i / segments;    //set y position from 0 - 1

                for ( let j = 0; j <= segments; j++ ) {

                    const x = j / segments;    //set x position from 0 - 1

                    vertices.push( x, y, 0 );
                    normals.push( 0, 0, 1 );

                    colors.push( 0,0,1 );
                }
            }

            // generate indices (data for element array buffer)
            for ( let i = 0; i < segments; i++ ) {

                for ( let j = 0; j < segments; j++ ) {

                    const a = i * ( segments + 1 ) + ( j + 1 );
                    const b = i * ( segments + 1 ) + j;
                    const c = ( i + 1 ) * ( segments + 1 ) + j;
                    const d = ( i + 1 ) * ( segments + 1 ) + ( j + 1 );

                    // generate two faces (triangles) per iteration
                    indices.push( a, b, d ); // face one
                    indices.push( b, c, d ); // face two
                }
            }

            geometry.setIndex( indices );            
            const colorsA = new THREE.Float32BufferAttribute(colors,3);
            const positionsA = new THREE.Float32BufferAttribute(vertices,3);
            const normalsA = new THREE.Float32BufferAttribute(normals,3);
            geometry.setAttribute( 'color', colorsA);
            geometry.setAttribute( 'position', positionsA );
            geometry.setAttribute( 'normal', normalsA );

            const mesh = new THREE.Mesh( geometry, refractiveMat );
            mesh.position.x = -0.5;
            mesh.position.y = -0.5;
            scene.add( mesh );

            const torusGeometry = new THREE.TorusKnotGeometry(10, 2.3, 300, 24);
            const bgMesh = new THREE.Mesh( torusGeometry, normalMat);
            bgMesh.position.z = -0.5;
            bgMesh.scale.x = 0.02;
            bgMesh.scale.y = 0.02;
            bgMesh.scale.z = 0.02;
			scene.add(bgMesh);

            // const wireframe = new THREE.WireframeGeometry(geometry);
            // const lineMat = new THREE.LineBasicMaterial({
            //     //vertexColors: true,
            //     color: 0xffffff,
            //     depthTest: false,
            //     opacity: 1.0,
            //     transparent: false,
            //     side: THREE.DoubleSide
            // });
            // const line = new THREE.LineSegments(wireframe, lineMat);
            // line.material.depthTest = false;
            // line.material.opacity = 1.0;
            // line.material.transparent = false;
            // scene.add(line);

            document.body.addEventListener( 'pointermove', onPointerMove );

            const prev = new Array(points * points).fill(0);
            const curr = new Array(points * points).fill(0);

            animate(scene, camera); 

            function onPointerMove( event ) {

                if ( event.isPrimary === false ) return;

                mouseX = event.clientX;
                mouseY = event.clientY;

                indX = Math.floor((mouseX / window.innerWidth) * points);
                indY = Math.floor((1 - mouseY / window.innerHeight) * points);
                
                for (let i = -(pointerSize-1); i < pointerSize; i++) {
                    const xtemp = i + indX;
                    for (let j = -(pointerSize-1); j < pointerSize; j++) {
                        const ytemp = j + indY;
                        if (0 < xtemp && xtemp < segments && 0 < ytemp && ytemp < segments) {
                            const indtemp = xtemp + (ytemp * points);
                            prev[indtemp] += pointerStrength * (pointerSize - (Math.abs(i) + Math.abs(j))) / pointerSize;
                        }
                    }
                }

                xPos.innerHTML = mouseX;
                yPos.innerHTML = mouseY;
                indXP.innerHTML = indX;
                indYP.innerHTML = indY;
                extra.innerHTML = "prev[" + (indX + (indY * points)) + "] = " + prev[ind];
            }

            function buttonfunc() {
                for (let i = 0; i < points*points; i++) {
                    colorsA.setX(i,1);
                }
            }

            function rippleAnimate() {
                for (let x = 1; x < points; x++) {
                    for (let y = 1; y < points; y++) {
                        curr[x + (y * points)] = (prev[(x-1) + y * points] + 
                                                  prev[(x+1) + y * points] + 
                                                  prev[x + (y+1) * points] + 
                                                  prev[x + (y-1) * points]) / 2 - curr[x + (y * points)];
                        curr[x + (y * points)] = curr[x + (y * points)] * damping;
                        curr[x + (y * points)] = isNaN(curr[x + (y * points)]) ? 0 : curr[x + (y * points)];
                    }
                }

                for (let i = 0; i < points*points; i++) {
                    normalsA.setY(i,curr[i]);
                }

                for (let i = 0; i < points*points; i++) {
                    const temp = prev[i];
                    prev[i] = curr[i];
                    curr[i] = temp;
                }

                normalsA.needsUpdate = true;
            }

            //frame update
            function animate() {
                requestAnimationFrame( animate );

				bgMesh.rotation.x += 0.01;
				bgMesh.rotation.y += 0.01;
                
                if (readyToRender) {
                    rippleAnimate()
                    renderer.render( scene, camera );
                    readyToRender = false;
                    intervalID = setInterval(queueRender, msPerFrame);
                }                
            }

            function resizeCanvas() {
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            window.addEventListener('resize', resizeCanvas)
            
		</script>
        <div style="display: flex; flex-direction: column; position: fixed; top: 0; color: white;">
            <p id="xPos">xPos</p>
            <p id="yPos">yPos</p>
            <p id="indXP"></p>
            <p id="indYP"></p>
            <p id="extra"></p>
            <button onclick="buttonfunc()" id="butt" style="width: 100px;">hi</button>
        </div>
	</body>
</html>