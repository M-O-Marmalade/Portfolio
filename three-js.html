<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>three-js</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
        <script src="js/three.js"></script>
		<script>

            const segments = Math.sqrt(100000);
            const fps = 120;
            const msPerFrame = 1000/fps;
            let readyToRender = true;
            let intervalID;
            const damping = 0.984;
            const pointerStrength = 0.037;
            const pointerSize = 4;

            let wX = window.innerWidth;
            let wY = window.innerHeight;
            let aspect = wX / wY;
            const total = wX + wY;
            let xPer = wX / total;
            let yPer = wY / total;
            let ySeg = Math.floor(yPer * segments);
            let xSeg = Math.floor(xPer * segments);
            let yPoi = ySeg + 1;
            let xPoi = xSeg + 1;

            const prev = new Array(xPoi * yPoi).fill(0);
            const curr = new Array(xPoi * yPoi).fill(0);
            
            //scene & camera
            const scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x0044ff );
            // const camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0.1, 1000);
            const camera = new THREE.PerspectiveCamera(53, wX / wY, 0.5, 1000)
            camera.position.x = 0;
            camera.position.y = 0;
            camera.position.z = 1;
            camera.lookAt(0,0,0);

            //renderer
            const renderer = new THREE.WebGLRenderer();
            // renderer.alpha = true;
            // renderer.setClearColor(0x000000, 0);
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( wX, wY );
            document.body.appendChild( renderer.domElement );

            // light
            const light = new THREE.DirectionalLight(0xffffff);
            light.position.set(10,0,0);
            //scene.add( light );

            // materials
            const refractiveMat = new THREE.MeshPhysicalMaterial({
                side: THREE.DoubleSide,
                transmission: 1.0,
				roughness: 0,
				ior: 1.333,
				thickness: 10,
            });

            const normalMat = new THREE.MeshNormalMaterial({
                side: THREE.DoubleSide
            });

            const vertMat = new THREE.MeshBasicMaterial({
                vertexColors: true,
                side: THREE.BackSide
            });

            // geometry
            const geometry = new THREE.BufferGeometry();

            //attributes
            const indices = [];
            const vertices = [];
            const normals = [];
            const colors = [];

            // generate vertices, normals and color data for a simple grid geometry
            for ( let i = 0; i < yPoi; i++ ) {

                const y = (i / ySeg) - 0.5;    //set y position from 0 - 1

                for ( let j = 0; j < xPoi; j++ ) {

                    const x = ((j / xSeg) - 0.5) * aspect;    //set x position from 0 - 1

                    vertices.push( x, y, 0 );
                    normals.push( 0, 0, -1 );
                    colors.push( x,y,x/2 + y/2 );
                }
            }

            // generate indices (data for element array buffer)
            for ( let i = 0; i < ySeg; i++ ) {

                for ( let j = 0; j < xSeg; j++ ) {

                    const a = i * ( xSeg + 1 ) + ( j + 1 );
                    const b = i * ( xSeg + 1 ) + j;
                    const c = ( i + 1 ) * ( xSeg + 1 ) + j;
                    const d = ( i + 1 ) * ( xSeg + 1 ) + ( j + 1 );

                    // generate two faces (triangles) per iteration
                    indices.push( a, b, d ); // face one
                    indices.push( b, c, d ); // face two
                }
            }

            geometry.setIndex( indices );            
            const colorsA = new THREE.Float32BufferAttribute(colors,3);
            const positionsA = new THREE.Float32BufferAttribute(vertices,3);
            const normalsA = new THREE.Float32BufferAttribute(normals,3);
            geometry.setAttribute( 'color', colorsA);
            geometry.setAttribute( 'position', positionsA );
            geometry.setAttribute( 'normal', normalsA );

            const mesh = new THREE.Mesh( geometry, refractiveMat );
            scene.add( mesh );

            const torusGeometry = new THREE.TorusKnotGeometry(10, 2.3, 300, 24);
            const bgMesh = new THREE.Mesh( torusGeometry, normalMat);
            bgMesh.position.z = -0.5;
            bgMesh.scale.x = 0.07;
            bgMesh.scale.y = 0.03;
            bgMesh.scale.z = 0.02;
			scene.add(bgMesh);

            document.body.addEventListener( 'mousemove', onMouseMove );
            document.body.addEventListener( 'touchmove', onTouchMove );

            animate(scene, camera);             

            function queueRender() {
                readyToRender = true;
                clearInterval(intervalID);
            }
            intervalID = setInterval(queueRender, msPerFrame);

            function pointerMove(x, y) {
                const indX = Math.floor((x / wX) * xPoi);
                const indY = Math.floor((1 - y / wY) * yPoi);
                
                for (let i = -(pointerSize-1); i < pointerSize; i++) {
                    const xtemp = i + indX;
                    for (let j = -(pointerSize-1); j < pointerSize; j++) {
                        const ytemp = j + indY;
                        if (0 < xtemp && xtemp < xSeg && 0 < ytemp && ytemp < ySeg) {
                            const indtemp = xtemp + (ytemp * xPoi);
                            prev[indtemp] += pointerStrength * (pointerSize - (Math.abs(i) + Math.abs(j))) / pointerSize;
                        }
                    }
                }
            }

            function onTouchMove(e) {
                for(let i = 0; i < e.touches.length; i++) {
                    pointerMove(e.touches[i].clientX, e.touches[i].clientY);
                }
            }

            function onMouseMove(e) {
                pointerMove(e.clientX, e.clientY)                

                xPos.innerHTML = "mouseX: " + e.clientX;
                yPos.innerHTML = "mouseY: " + e.clientY;
                indXP.innerHTML = "indX: " + indX;
                indYP.innerHTML = "indY: " + indY;
            }

            function rippleAnimate() {
                for (let x = 1; x < xPoi; x++) {
                    for (let y = 1; y < yPoi; y++) {
                        curr[x + (y * xPoi)] = (prev[(x-1) + y * xPoi] + 
                                                  prev[(x+1) + y * xPoi] + 
                                                  prev[x + (y+1) * xPoi] + 
                                                  prev[x + (y-1) * xPoi]) / 2 - curr[x + (y * xPoi)];
                        curr[x + (y * xPoi)] = curr[x + (y * xPoi)] * damping;
                        curr[x + (y * xPoi)] = isNaN(curr[x + (y * xPoi)]) ? 0 : curr[x + (y * xPoi)];
                    }
                }

                for (let i = 0; i < xPoi*yPoi; i++) {
                    normalsA.setY(i,curr[i]);
                    normalsA.setX(i,curr[i]);
                }

                for (let i = 0; i < xPoi*yPoi; i++) {
                    const temp = prev[i];
                    prev[i] = curr[i];
                    curr[i] = temp;
                }

                normalsA.needsUpdate = true;
                extra.innerHTML = prev[xPoi * yPoi / 2];
            }

            //frame update
            function animate() {
                requestAnimationFrame( animate );

				// bgMesh.rotation.x += 0.01;
				// bgMesh.rotation.y += 0.01;
                
                if (readyToRender) {
                    rippleAnimate()
                    renderer.render( scene, camera );
                    readyToRender = false;
                    intervalID = setInterval(queueRender, msPerFrame);
                }

                wXP.innerHTML = "wX: " + wX;
                wYP.innerHTML = "wY: " + wY;
                xPerP.innerHTML = "xPer: " + xPer;
                yPerP.innerHTML = "yPer: " + yPer;
                ySegP.innerHTML = "ySeg: " + ySeg;
                xSegP.innerHTML = "xSeg: " + xSeg;
                yPoiP.innerHTML = "yPoi: " + yPoi;
                xPoiP.innerHTML = "xPoi: " + xPoi;
            }

            function resizedWindow() {
                wX = window.innerWidth;
                wY = window.innerHeight;
                renderer.setSize(wX, wY);
            }
            window.addEventListener('resize', resizedWindow)
            
		</script>
        <div style="display: flex; flex-direction: column; position: fixed; top: 0; color: white;">
            <p id="xPos">xPos</p>
            <p id="yPos">yPos</p>
            <p id="indXP"></p>
            <p id="indYP"></p>
            <p id="extra"></p>
            <p id="wXP"></p>
            <p id="wYP"></p>
            <p id="xPerP"></p>
            <p id="yPerP"></p>
            <p id="ySegP"></p>
            <p id="xSegP"></p>
            <p id="yPoiP"></p>
            <p id="xPoiP"></p>
        </div>
	</body>
</html>